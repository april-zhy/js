<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>02--prototype模式</title>
</head>
<body>
    <script typeof="text/javascript">
        //原型模式创建对象
        /*我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象
        * 而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法
        *
        * prototype通过调用构造函数而创建的那个对象实例的原型对象
        *
        * 好处：可以让所有对象实例共享它所办函的属性和方法*/
        //构造函数
        function Person() {}

        Person.prototype.name='zhy';
        Person.prototype.age=20;
        Person.prototype.job='SE';
        Person.prototype.sayName=function () {
            return this.name;
        }

        var p1=new Person();

        var p3=new Person();
        var p4=new Person();
        // p3.sayName();
        console.log( '1: '+Person.prototype.constructor );
        console.log('2: '+ p3.constructor );
        console.log('2: '+ p3.constructor==p4.constructor +'\n');//false


        /*console.log( Person.prototype.constructor==Person );//true
        console.log( p1.constructor==Person );//true
        console.log( Person.prototype.constructor );//function Person(){}*/

        /* console.log( Person.prototype.isPrototypeOf(p1) );//true
         console.log( p1.__proto__ );
         console.log( p1.sayName() );

         p1.sex='female';
         console.log( p1.hasOwnProperty("sex") );//true
         console.log( p1.hasOwnProperty("name") );//false
         console.log( p1.hasOwnProperty("age") );//false
         console.log( p1.hasOwnProperty('job') );//false*/
        /*在此，我们将sayName方法和所有属性直接添加到了Persom的prototype
        * 属性中，构造函数变成了空函数，即便如此，仍然可以通过调用构造函数来创建
        * 新对象，而且新对象还会具有相同的属性和方法*
        *
        * 注意：新对象的这些属性和方法是由所有实例所共享的，换句话说，
        * p1和p2访问的是同一组属性和同一个sayName函数*/


        /*理解原型对象
        * 无论什么时候，只要创建了一个新函数，就会根据一组特定的规则
        * 为函数创建一个prototype属性，这个属性指向函数的原型对象，
        * 在默认情况下，所有原型对象都会自动获得一个constructor属性
        * 这个属性包含一个指向prototype属性所在函数的指针
        *
        * */
    </script>
</body>
</html>